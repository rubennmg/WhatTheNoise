/* ------------------------------------------*/
/* ------ THIS FILE WAS GENERATED BY CHAT GPT ------ */
/* ------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "portaudio.h"

#define NUM_CHANNELS 1
#define SAMPLE_RATE 44100
#define FRAMES_PER_BUFFER 512
#define NUM_SECONDS 5

#define NUM_MICROPHONES 2

#define SOUND_SPEED 343.0 // Speed of sound in meters per second

// Estructura para almacenar los datos de audio grabados
typedef struct {
    float* samples[NUM_MICROPHONES];
    int frameIndex;
    int maxFrameIndex;
} RecordingData;

// Función de callback para capturar audio
static int audioCallback(const void* inputBuffer, void* outputBuffer,
                         unsigned long framesPerBuffer,
                         const PaStreamCallbackTimeInfo* timeInfo,
                         PaStreamCallbackFlags statusFlags,
                         void* userData) {
    RecordingData* data = (RecordingData*)userData;
    const float* inBuffer = (const float*)inputBuffer;

    // Almacenar las muestras de audio en cada micrófono
    for (int mic = 0; mic < NUM_MICROPHONES; mic++) {
        float* micBuffer = data->samples[mic];
        for (unsigned int i = 0; i < framesPerBuffer; i++) {
            micBuffer[data->frameIndex] = inBuffer[i * NUM_CHANNELS + mic];
            data->frameIndex++;
        }
    }

    return paContinue;
}

// Función para calcular la diferencia de tiempo de llegada (TDOA)
double calculateTDOA(const float* mic1Samples, const float* mic2Samples, int sampleRate, int numSamples) {
    // Encuentra el punto de cruzada inicial (cross-correlation)
    int maxDelay = sampleRate / 2; // Max delay in samples (0.5 seconds)
    double maxCorrelation = 0.0;
    int maxDelayIndex = 0;
    for (int delay = -maxDelay; delay < maxDelay; delay++) {
        double correlation = 0.0;
        for (int i = 0; i < numSamples - abs(delay); i++) {
            correlation += mic1Samples[i] * mic2Samples[i + delay];
        }
        if (correlation > maxCorrelation) {
            maxCorrelation = correlation;
            maxDelayIndex = delay;
        }
    }

    // Convertir el retraso de muestras a tiempo (en segundos)
    double tdoa = (double)maxDelayIndex / (double)sampleRate;
    return tdoa;
}

int main(void) {
    PaError err;
    PaStream* stream;
    RecordingData data;
    int numSamples = NUM_SECONDS * SAMPLE_RATE;
    int numBytesPerMic = numSamples * sizeof(float);

    // Inicializar datos de grabación
    for (int mic = 0; mic < NUM_MICROPHONES; mic++) {
        data.samples[mic] = (float*)malloc(numBytesPerMic);
        if (!data.samples[mic]) {
            fprintf(stderr, "Error: No se pudo asignar memoria para la grabación.\n");
            return 1;
        }
    }
    data.frameIndex = 0;
    data.maxFrameIndex = numSamples;

    // Inicializar PortAudio
    err = Pa_Initialize();
    if (err != paNoError) {
        fprintf(stderr, "Error al inicializar PortAudio: %s\n", Pa_GetErrorText(err));
        return 1;
    }

    // Configurar parámetros de audio
    PaStreamParameters inputParameters;
    inputParameters.device = Pa_GetDefaultInputDevice();
    inputParameters.channelCount = NUM_CHANNELS;
    inputParameters.sampleFormat = paFloat32;
    inputParameters.suggestedLatency = Pa_GetDeviceInfo(inputParameters.device)->defaultLowInputLatency;
    inputParameters.hostApiSpecificStreamInfo = NULL;

    // Abrir el stream de audio
    err = Pa_OpenStream(&stream, &inputParameters, NULL, SAMPLE_RATE, FRAMES_PER_BUFFER, paClipOff, audioCallback, &data);
    if (err != paNoError) {
        fprintf(stderr, "Error al abrir el stream de audio: %s\n", Pa_GetErrorText(err));
        Pa_Terminate();
        return 1;
    }

    // Iniciar la captura de audio
    err = Pa_StartStream(stream);
    if (err != paNoError) {
        fprintf(stderr, "Error al iniciar la captura de audio: %s\n", Pa_GetErrorText(err));
        Pa_CloseStream(stream);
        Pa_Terminate();
        return 1;
    }

    printf("Grabando %d segundos de audio...\n", NUM_SECONDS);
    Pa_Sleep(NUM_SECONDS * 1000); // Esperar hasta que se complete la grabación

    // Detener la captura de audio
    err = Pa_StopStream(stream);
    if (err != paNoError) {
        fprintf(stderr, "Error al detener la captura de audio: %s\n", Pa_GetErrorText(err));
    }

    // Calcular la diferencia de tiempo de llegada (TDOA) entre los dos micrófonos
    double tdoa = calculateTDOA(data.samples[0], data.samples[1], SAMPLE_RATE, numSamples);

    // Calcular la distancia entre los micrófonos utilizando el TDOA y la velocidad del sonido
    double distance = fabs(tdoa) * SOUND_SPEED;

    // Determinar la dirección de origen del sonido
    printf("La diferencia de tiempo de llegada (TDOA) entre los micrófonos es: %lf segundos\n", tdoa);
    printf("La distancia entre los micrófonos es: %lf metros\n", distance);

    // Limpiar y terminar
    for (int mic = 0; mic < NUM_MICROPHONES; mic++) {
        free(data.samples[mic]);
    }
    Pa_CloseStream(stream);
    Pa_Terminate();

    return 0;
}
